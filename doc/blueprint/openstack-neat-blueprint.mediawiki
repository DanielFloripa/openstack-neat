<h1 id="summary">Summary</h1>
<p>OpenStack Neat is a project intended to provide an extension to OpenStack implementing dynamic consolidation of Virtual Machines (VMs) using live migration. The major objective of dynamic VM consolidation is to improve the utilization of physical resources and reduce energy consumption by re-allocating VMs using live migration according to their real-time resource demand and switching idle hosts to the sleep mode. For example, assume that two VMs are placed on two different hosts, but the combined resource capacity required by the VMs to serve the current load can be provided by just one of the hosts. Then, one of the VMs can be migrated to the host serving the other VM, and the idle host can be switched to a low power mode to save energy.</p>
<p>Apart from consolidating VMs, the system should be able to react to increases in the resource demand and deconsolidate VMs when necessary to avoid performance degradation. In general, the problem of dynamic VM consolidation can be split into 4 sub-problems:</p>
<ol style="list-style-type: decimal">
<li>Deciding when a host is considered to be underloaded, so that all the VMs should be migrated from it, and the host should be switched to a low power mode, such as the sleep mode.</li>
<li>Deciding when a host is considered to be overloaded, so that some VMs should be migrated from the host to other hosts to avoid performance degradation.</li>
<li>Selecting VMs to migrate from an overloaded host out of the full set of the VMs currently served by the host.</li>
<li>Placing VMs selected for migration to other active or re-activated hosts.</li>
</ol>
<p>This work is a part of PhD research conducted within the <a href="http://www.cloudbus.org/">Cloud Computing and Distributed Systems (CLOUDS) Laboratory</a> at the University of Melbourne. The problem of dynamic VM consolidation considering Quality of Service (QoS) constraints has been studied from the theoretical perspective and algorithms addressing the sub-problems listed above have been proposed <span class="citation">[1], [2]</span>. The algorithms have been evaluated using <a href="http://code.google.com/p/cloudsim/">CloudSim</a> and real-world workload traces collected from more than a thousand <a href="https://www.planet-lab.org/">PlanetLab</a> VMs hosted on servers located in more than 500 places around the world.</p>
<p>The aim of the OpenStack Neat project is to provide an extensible framework for dynamic consolidation of VMs based on the OpenStack platform. The framework should provide an infrastructure enabling the interaction of components implementing the 4 decision-making algorithms listed above. The framework should allow configuration-driven switching of different implementations of the decision-making algorithms. The implementation of the framework will include the algorithms proposed in our previous works <span class="citation">[1], [2]</span>.</p>
<h1 id="release-note">Release Note</h1>
<p>The functionality covered by this project will be implemented in the form of services separate from the core OpenStack services. The services of this project will interact with the core OpenStack services using their public APIs. It will be required to create a new Keystone user within the <code>service</code> tenant. The project will also require a new MySQL database for storing historical data on the resource usage by VMs. The project will provide a script for automated initialization of the database. The services provided by the project will need to be run on the management as well as compute hosts.</p>
<h1 id="rationale">Rationale</h1>
<p>The problem of data center operation is high energy consumption, which has risen by 56% from 2005 to 2010, and in 2010 accounted to be between 1.1% and 1.5% of the global electricity use <span class="citation">[3]</span>. Apart from high operating costs, this results in substantial carbon dioxide (CO<sub>2</sub>) emissions, which are estimated to be 2% of the global emissions <span class="citation">[4]</span>. The problem has been partially addressed by improvements in the physical infrastructure of modern data centers. As reported by <a href="http://opencompute.org/">the Open Compute Project</a>, Facebook’s Oregon data center achieves a Power Usage Effectiveness (PUE) of 1.08, which means that approximately 93% of the data center’s energy consumption are consumed by the computing resources. Therefore, now it is important to focus on the resource management aspect, i.e. ensuring that the computing resources are efficiently utilized to serve applications.</p>
<p>Dynamic consolidation of VMs has been shown to be efficient in improving the utilization of data center resources and reducing energy consumption, as demonstrated by numerous studies <span class="citation">[5–16]</span>. In this project, we aim to implement an extensible framework for dynamic VM consolidation specifically targeted at the OpenStack platform.</p>
<h1 id="user-stories">User stories</h1>
<ul>
<li>As a Cloud Administrator or Systems Integrator, I want to support dynamic VM consolidation to improve the utilization of the data center’s resources and reduce energy consumption.</li>
<li>As a Cloud Administrator, I want to minimize the price of the service provided to the consumers by reducing the operating costs through the reduced energy consumption.</li>
<li>As a Cloud Administrator, I want to decrease the carbon dioxide emissions into the environment by reducing the energy consumption by the data center’s resources.</li>
<li>As a Cloud Administrator, I want to provide QoS guarantees to the consumers, while applying dynamic VM consolidation.</li>
<li>As a Cloud Service Consumer, I want to pay the minimum price for the service provided through the minimized energy consumption of the computing resources.</li>
<li>As a Cloud Service Consumer, I want to use Green Cloud resources, whose provider strives to reduce the impact on the environment in terms of carbon dioxide emissions.</li>
</ul>
<h1 id="assumptions">Assumptions</h1>
<ul>
<li>Nova uses a <em>shared storage</em> for storing VM instance data, thus supporting <em>live migration</em> of VMs. For example, a shared storage can be provided using Network File System (NFS), or GlusterFS as described in <span class="citation">[17]</span>.</li>
<li>All the compute hosts must have a user, which is enabled to switch the machine into the sleep mode, which is also referred to as “Suspend to RAM”. This user is used by the global controller to connect to the compute hosts using SSH and switch them into the sleep mode when necessary.</li>
</ul>
<h1 id="design">Design</h1>
<div class="figure">
<img src="https://github.com/beloglazov/openstack-neat/raw/master/doc/blueprint/src/openstack-neat-deployment-diagram.png" alt="The deployment diagram" /><p class="caption">The deployment diagram</p>
</div>
<p>The system is composed of a number of components and data stores, some of which are deployed on the compute hosts, and some on the management host (Figure 1). In the following sections, we discuss the design and interaction of the components, as well as the specification of the data stores.</p>
<h2 id="components">Components</h2>
<p>As shown in Figure 1, the system is composed of three main components:</p>
<ul>
<li><em>Global manager</em> – a component that is deployed on the management host and makes global management decisions, such as mapping VM instances on hosts, and initiating VM migrations.</li>
<li><em>Local manager</em> – a component that is deployed on every compute host and makes local decisions, such as deciding that the host is underloaded or overloaded, and selecting VMs to migrate to other hosts.</li>
<li><em>Data collector</em> – a component that is deployed on every compute host and is responsible for collecting data about the resource usage by VM instances, as well as storing these data locally and submitting the data to the central database.</li>
</ul>
<h3 id="global-manager">Global Manager</h3>
<div class="figure">
<img src="https://github.com/beloglazov/openstack-neat/raw/master/doc/blueprint/src/openstack-neat-sequence-diagram.png" alt="The global manager: a sequence diagram" /><p class="caption">The global manager: a sequence diagram</p>
</div>
<p>The global manager is deployed on the management host and is responsible for making VM placement decisions and initiating VM migrations. It exposes a REST web service, which accepts requests from local managers. The global manager processes only one type of requests – reallocation of a set of VM instances. As shown in Figure 2, once a request is received, the global manager invokes a VM placement algorithm to determine destination hosts to migrate the VMs to. Once a VM placement is determined, the global manager submits a request to the Nova API to migrate the VMs. The global manager is also responsible for switching idle hosts to the sleep mode, as well as re-activating hosts when necessary.</p>
<h4 id="vm-placement.">VM Placement.</h4>
<p>The global manager is agnostic of a particular implementation of the VM placement algorithm in use. The VM placement algorithm to use can be specified in the configuration file described later using the <code>algorithm_vm_placement</code> option. A VM placement algorithm can call the Nova API to obtain the information about host characteristics and current VM placement. If necessary, it can also query the central database to obtain the historical information about the resource usage by the VMs.</p>
<h4 id="rest-api.">REST API.</h4>
<p>The global manager exposes a REST web service (REST API) for accepting VM migration requests from local managers. The service URL is defined according to configuration options defined in <code>/etc/neat/neat.conf</code>, which is discussed further in the paper. The two relevant options are:</p>
<ul>
<li><code>global_manager_host</code> – the name of the host running the global manager;</li>
<li><code>global_manager_port</code> – the port of the REST web service exposed by the global manager.</li>
</ul>
<p>The service URL is composed as follows:</p>
<pre><code>http://&lt;global_manager_host&gt;:&lt;global_manager_port&gt;/</code></pre>
<p>Since the global manager processes only a single type of requests, it exposes only one resource: <code>/</code>. The resource is accessed using the method <code>PUT</code>, which initiates the VM reallocation process. This service requires the following parameters:</p>
<ul>
<li><code>admin_tenant_name</code> – the admin tenant name of Neat’s admin user registered in Keystone. This parameter is not used to authenticate in any OpenStack service, rather it is used to authenticate the client making a request as being allowed to access the web service.</li>
<li><code>admin_user</code> – the admin user name of Neat’s admin user registered in Keystone. This parameter is not used to authenticate in any OpenStack service, rather it is used to authenticate the client making a request as being allowed to access the web service.</li>
<li><code>admin_password</code> – the admin password of Neat’s admin user registered in Keystone. This parameter is not used to authenticate in any OpenStack service, rather it is used to authenticate the client making a request as being allowed to access the web service.</li>
<li><code>vm_uuids</code> – a coma-separated list of UUIDs of the VMs required to be migrated.</li>
<li><code>reason</code> – a string specifying the resource for migration: “underload”, or “overload”.</li>
</ul>
<p>If the provided credentials are correct and the <code>vm_uuids</code> parameter includes a list of UUIDs of existing VMs in the correct format, the service responses with the HTTP status code <code>200 OK</code>.</p>
<p>The service uses standard HTTP error codes to response in cases of errors detected. The following error codes are used:</p>
<ul>
<li><code>400</code> – bad input parameter: incorrect or missing parameters;</li>
<li><code>401</code> – unauthorized: user credentials are missing;</li>
<li><code>403</code> – forbidden: user credentials do not much the ones specified in the configuration file;</li>
<li><code>405</code> – method not allowed: the request is made with a method other than the only supported <code>PUT</code>;</li>
<li><code>422</code> – unprocessable entity: one or more VMs could not be found using the list of UUIDs specified in the <code>vm_uuids</code> parameter.</li>
</ul>
<h4 id="switching-hosts-on-and-off.">Switching Hosts On and Off.</h4>
<p>One of the main features required to be supported by the hardware in order to take advantage of dynamic VM consolidation to save energy is <a href="http://en.wikipedia.org/wiki/Wake-on-LAN">Wake-on-Lan</a>. This technology allows a computer being in the sleep (Suspend to RAM) mode to be re-activated by sending a special packet over network. This technology has been introduced in 1997 by the Advanced Manageability Alliance (AMA) formed by Intel and IBM, and is currently supported by most of the modern hardware.</p>
<p>Once the required VM migrations are completed, the global manager connects to the source host and switches into in the Suspend to RAM mode. Switching to the Suspend to RAM mode can be done, for example, using programs included in the <code>pm-utils</code> package. To check whether the Suspend to RAM mode is supported:</p>
<pre class="sourceCode Bash"><code class="sourceCode bash">pm-is-supported --suspend</code></pre>
<p>The Suspend to RAM mode is supported if the command returns 0, otherwise it is not supported. In this case, the Suspend to RAM mode can be replaced with the Standby or Suspend to Disk (Hibernate) modes. The following command can be used to switch the host into the Suspend to RAM mode:</p>
<pre class="sourceCode Bash"><code class="sourceCode bash">pm-suspend</code></pre>
<p>To re-activate a host using the Wake-on-Lan technology, it is necessary to send a special packet, called the <em>magic packet</em>. This can be done using the <code>ether-wake</code> program as follows:</p>
<pre class="sourceCode Bash"><code class="sourceCode bash">ether-wake <span class="kw">&lt;</span>mac address<span class="kw">&gt;</span></code></pre>
<p>Where <code>&lt;mac address&gt;</code> is replaced with the actual MAC address of the host.</p>
<h3 id="local-manager">Local Manager</h3>
<div class="figure">
<img src="https://github.com/beloglazov/openstack-neat/raw/master/doc/blueprint/src/openstack-neat-local-manager.png" alt="The local manager: an activity diagram" /><p class="caption">The local manager: an activity diagram</p>
</div>
<p>The local manager component is deployed on every compute host and is invoked periodically to determine when it necessary to reallocate VM instances from the host. A high-level view of the workflow performed by the local manager is shown in Figure 3. First of all, it reads from the local storage the historical data about the resource usage by the VMs stored by the data collector described in the next section. Then, the local manager invokes the specified in the configuration underload detection algorithm to determine whether the host is underloaded. If the host is underloaded, the local manager sends a request to the global manager’s REST interface to migrate all the VMs from the host and switch the host to the sleep mode.</p>
<p>If the host is not underloaded, the local manager proceeds to invoking the specified in the configuration overload detection algorithm. If the host is overloaded, the local manager invokes the configured VM selection algorithm to select the VMs to migrate from the host. Once the VMs to migrate from the host are selected, the local manager sends a request to the global manager’s REST interface to migrate the selected VMs from the host.</p>
<p>Similarly to the global manager, the local manager can be configured to use specific underload detection, overload detection, and VM selection algorithm using the configuration file discussed further in the paper.</p>
<h4 id="underload-detection.">Underload Detection.</h4>
<p>Underload detection is done by a specified in the configuration underload detection algorithm (<code>algorithm_underload_detection</code>). The algorithm has a pre-defined interface, which allows substituting different implementations of the algorithm. The configured algorithm is invoked by the local manager and accepts historical data about the resource usage by the VMs running on the host as an input. An underload detection algorithm returns a decision of whether the host is underloaded.</p>
<h4 id="overload-detection.">Overload Detection.</h4>
<p>Overload detection is done by a specified in the configuration overload detection algorithm (<code>algorithm_overload_detection</code>). Similarly to underload detection, all overload detection algorithms implement a pre-defined interface to enable configuration-driven substitution of difference implementations. The configured algorithm is invoked by the local manager and accepts historical data about the resource usage by the VMs running on the host as an input. An overload detection algorithm returns a decision of whether the host is overloaded.</p>
<h4 id="vm-selection.">VM Selection.</h4>
<p>If a host is overloaded, it is necessary to select VMs to migrate from the host to avoid performance degradation. This is done by a specified in the configuration VM selection algorithm (<code>algorithm_vm_selection</code>). Similarly to underload and overload detection algorithms, different VM selection algorithm can plugged in according to the configuration. A VM selection algorithm accepts historical data about the resource usage the VMs running on the host and returns a set of VMs to migrate from the host.</p>
<h3 id="data-collector">Data Collector</h3>
<p>The data collector is deployed on every compute host and is executed periodically to collect the CPU utilization data for each VM running on the host and stores it in the local file-based data store. The data is collected in average number of MHz consumed by a VM during the last measurement interval. The CPU usage data are stored as integers. This data format is portable: the collected values can be converted to the CPU utilization for any host or VM type, supporting heterogeneous hosts and VMs.</p>
<p>The actual data is obtained from Libvirt in the form of the CPU time consumed by a VM to date. Using the CPU time collected at the previous time frame, the CPU time for the past time interval is calculated. According to the CPU frequency of the host and the length of the time interval, the CPU time is converted into the required average MHz consumed by the VM over the last time interval. The collected data are stored both locally and submitted to the central database. The number of the latest data values stored locally and passed to the underload / overload detection and VM selection algorithms is defined using the <code>data_collector_data_length</code> option in the configuration file.</p>
<p>At the beginning of every execution, the data collector obtains the set of VMs currently running on the host using the Nova API and compares them to the VMs running on the host at the previous time step. If new VMs have been found, the data collector fetches the historical data about them from the central database and stores the data in the local file-based data store. If some VMs have been removed, the data collector removes the data about these VMs from the local data store.</p>
<h2 id="data-stores">Data Stores</h2>
<p>As shown in Figure 1, the system contains two types of data stores:</p>
<ul>
<li><em>Central database</em> – a database deployed on the management host.</li>
<li><em>Local file-based data storage</em> – a data store deployed on every compute host and used for storing resource usage data to use by local managers.</li>
</ul>
<p>The details about the data stores are given in the following subsections.</p>
<h3 id="central-database">Central Database</h3>
<p>The central database is used for storing historical data on the resource usage by VMs running on all the compute hosts. The database is populated by data collectors deployed on the compute hosts. The data are consumed by VM placement algorithms. The database contains two tables: <code>vms</code> and <code>vm_resource_usage</code>.</p>
<p>The <code>vms</code> table is used for storing the mapping between UUIDs of VMs and the internal database IDs:</p>
<pre><code>CREATE TABLE vms (
    # the internal ID of a VM
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    # the UUID of the VM
    uuid CHAR(36) NOT NULL,
    PRIMARY KEY (id)
) ENGINE=MyISAM;</code></pre>
<p>The <code>vm_resource_usage</code> table is used for storing the data about the resource usage by VMs:</p>
<pre><code>CREATE TABLE vm_resource_usage (
    # the ID of the record
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    # the id of the corresponding VM
    vm_id BIGINT UNSIGNED NOT NULL,
    # the time of the data collection
    timestamp TIMESTAMP NOT NULL,
    # the average CPU usage in MHz
    cpu_mhz MEDIUMINT UNSIGNED NOT NULL,
    PRIMARY KEY (id)
) ENGINE=MyISAM;</code></pre>
<h3 id="local-file-based-data-store">Local File-Based Data Store</h3>
<p>The data collector stores the resource usage information locally in files in the <code>&lt;local_data_directory&gt;/vm</code> directory, where <code>&lt;local_data_directory&gt;</code> is defined in the configuration file using the <code>local_data_directory</code> option. The data for each VM are stored in a separate file named according to the UUID of the corresponding VM. The format of the files is a new line separated list of integers representing the CPU consumption by the VMs in MHz.</p>
<h2 id="configuration-file">Configuration File</h2>
<p>The configuration of OpenStack Neat is stored in <code>/etc/neat/neat.conf</code> in the standard INI format using the <code>#</code> character for denoting comments. The configuration includes the following options:</p>
<ul>
<li><code>sql_connection</code> – the host name and credentials for connecting to the MySQL database specified in the format supported by SQLAlchemy;</li>
<li><code>admin_tenant_name</code> – the admin tenant name for authentication with Nova using Keystone;</li>
<li><code>admin_user</code> – the admin user name for authentication with Nova using Keystone;</li>
<li><code>admin_password</code> – the admin password for authentication with Nova using Keystone;</li>
<li><code>global_manager_host</code> – the name of the host running the global manager;</li>
<li><code>global_manager_port</code> – the port of the REST web service exposed by the global manager;</li>
<li><code>local_data_directory</code> – the directory used by the data collector to store the data on the resource usage by the VMs running on the host (the default value is <code>/var/lib/neat</code>);</li>
<li><code>local_manager_interval</code> – the time interval between subsequent invocations of the local manager in seconds;</li>
<li><code>data_collector_interval</code> – the time interval between subsequent invocations of the data collector in seconds;</li>
<li><code>data_collector_data_length</code> – the number of the latest data values stored locally by the data collector and passed to the underload / overload detection and VM placement algorithms;</li>
<li><code>compute_user</code> – the user name for connecting to the compute hosts to switch them into the sleep mode;</li>
<li><code>compute_password</code> – the password of the user account used for connecting to the compute hosts to switch them into the sleep mode;</li>
<li><code>sleep_command</code> – a shell command used to switch a host into the sleep mode, the <code>compute_user</code> must have permissions to execute this command (the default values is <code>pm-suspend</code>);</li>
<li><code>algorithm_underload_detection</code> – the fully qualified name of a Python function to use as an underload detection algorithm;</li>
<li><code>algorithm_overload_detection</code> – the fully qualified name of a Python function to use as an overload detection algorithm;</li>
<li><code>algorithm_vm_selection</code> – the fully qualified name of a Python function to use as a VM selection algorithm;</li>
<li><code>algorithm_vm_placement</code> – the fully qualified name of a Python function to use as a VM placement algorithm.</li>
</ul>
<h1 id="implementation">Implementation</h1>
<p>This section describes a plan of how the components described above are going to be implemented.</p>
<h2 id="libraries">Libraries</h2>
<p>The following third party libraries are planned to be used to implement the required components:</p>
<ol style="list-style-type: decimal">
<li><a href="https://github.com/Xion/pyqcy">pyqcy</a> – a QuickCheck-like testing framework for Python.</li>
<li><a href="http://andreacensi.github.com/contracts/">PyContracts</a> – a Python library for Design by Contract (DbC).</li>
<li><a href="http://www.sqlalchemy.org/">SQLAlchemy</a> – a Python SQL toolkit and Object Relational Mapper (used by the core OpenStack service).</li>
<li><a href="http://bottlepy.org/">Bottle</a> – a micro web-framework for Python, authentication using the same credentials using for Nova.</li>
<li><a href="https://github.com/openstack/python-novaclient">python-novaclient</a> – a Python Nova API client implementation.</li>
<li><a href="http://sphinx.pocoo.org/">Sphinx</a> – a documentation generator for Python.</li>
</ol>
<h2 id="global-manager-1">Global Manager</h2>
<p>The global manager component will provide a REST web service implemented using the Bottle framework. The authentication is going to be done using the admin credentials specified in the configuration file. Upon receiving a request from a local manager, the following steps will be performed:</p>
<ol style="list-style-type: decimal">
<li>Parse the <code>vm_uuids</code> parameter and transform it into a list of UUIDs of the VMs to migrate.</li>
<li>Call the Nova API to obtain the current placement of VMs on the hosts.</li>
<li>Call the function specified in the <code>algorithm_vm_placement</code> configuration option and pass the UUIDs of the VMs to migrate and the current VM placement as arguments.</li>
<li>Call the Nova API to migrate the VMs according to the placement determined by the <code>algorithm_vm_placement</code> algorithm.</li>
</ol>
<p>When a host needs to be switched to the sleep mode, the global manager will use the account credentials from the <code>compute_user</code> and <code>compute_password</code> configuration options to open an SSH connection with the target host and then invoke the command specified in the <code>sleep_command</code>, which defaults to <code>pm-suspend</code>.</p>
<p>When a host needs to be re-activated from the sleep mode, the global manager will leverage the Wake-on-Lan technology and send a magic packet to the target host using the <code>ether-wake</code> program and passing the corresponding MAC address as an argument. The mapping between the IP addresses of the hosts and their MAC addresses is initialized in the beginning of the global manager’s execution.</p>
<h2 id="local-manager-1">Local Manager</h2>
<p>The local manager will be implemented as a Linux daemon in the background and every <code>local_manager_interval</code> seconds checking whether some VMs should be migrated from the host. Every time interval, the local manager performs the following steps:</p>
<ol style="list-style-type: decimal">
<li>Read the data on resource usage by the VMs running on the host from the <code>&lt;local_data_directory&gt;/vm</code> directory.</li>
<li>Call the function specified in the <code>algorithm_underload_detection</code> configuration option and pass the data on the resource usage by the VMs, as well as the frequency of the CPU as arguments.</li>
<li>If the host is underloaded, send a request to the REST web service of the global manager and pass the list of the UUIDs of all the VMs currently running on the host in the <code>vm_uuids</code> paramter, as well as the <code>reason</code> for migration as being “underload”.</li>
<li>If the host is not underloaded, call the function specified in the <code>algorithm_overload_detection</code> configuration option and pass the data on the resource usage by the VMs, as well as the frequency of the host’s CPU as arguments.</li>
<li>If the host is overloaded, call the function specified in the <code>algorithm_vm_selection</code> configuration option and pass the data on the resource usage by the VMs, as well as the frequency of the host’s CPU as arguments</li>
<li>If the host is overloaded, send a request to the REST web service of the global manager and pass the list of the UUIDs of the VMs selected by the VM selection algorithm in the <code>vm_uuids</code> paramter, as well as the <code>reason</code> for migration as being “overload”.</li>
</ol>
<h2 id="data-collector-1">Data Collector</h2>
<p>The data collect will be implemented as a Linux daemon running in the background and collecting data on the resource usage by VMs every <code>data_collector_interval</code> seconds. When the data collection phase is invoked, the component performs the following steps:</p>
<ol style="list-style-type: decimal">
<li>Read the names of the files from the <code>&lt;local_data_directory&gt;/vm</code> directory to determine the list of VMs running on the host at the last data collection.</li>
<li>Call the Nova API to obtain the list of VMs that are currently active on the host.</li>
<li>Compare the old and new lists of VMs and determine the newly added or removed VMs.</li>
<li>Delete the files from the <code>&lt;local_data_directory&gt;/vm</code> directory corresponding to the VMs that have been removed from the host.</li>
<li>Fetch the latest <code>data_collector_data_length</code> data values from the central database for each newly added VM using the database connection information specified in the <code>sql_connection</code> option and save the data in the <code>&lt;local_data_directory&gt;/vm</code> directory.</li>
<li>Call the Libvirt API to obtain the CPU time for each VM active on the host.</li>
<li>Transform the data obtained from the Libvirt API into the average MHz according to the frequency of the host’s CPU and time interval from the previous data collection.</li>
<li>Store the converted data in the <code>&lt;local_data_directory&gt;/vm</code> directory in separate files for each VM, and submit the data to the central database.</li>
<li>Schedule the next execution after <code>data_collector_interval</code> seconds.</li>
</ol>
<h1 id="testdemo-plan">Test/Demo Plan</h1>
<p>This need not be added or completed until the specification is nearing beta.</p>
<h1 id="unresolved-issues">Unresolved issues</h1>
<p>This should highlight any issues that should be addressed in further specifications, and not problems with the specification itself; since any specification with problems cannot be approved.</p>
<h1 id="bof-agenda-and-discussion">BoF agenda and discussion</h1>
<p>Use this section to take notes during the BoF; if you keep it in the approved spec, use it for summarising what was discussed and note any options that were rejected.</p>
<h1 id="references">References</h1>
<p>[1] A. Beloglazov and R. Buyya, “Optimal online deterministic algorithms and adaptive heuristics for energy and performance efficient dynamic consolidation of virtual machines in Cloud data centers,” <em>Concurrency and Computation: Practice and Experience (CCPE)</em>, 2012.</p>
<p>[2] A. Beloglazov and R. Buyya, “Managing Overloaded Hosts for Dynamic Consolidation of Virtual Machines in Cloud Data Centers Under Quality of Service Constraints,” <em>IEEE Transactions on Parallel and Distributed Systems (TPDS)</em>, 2012 (under review).</p>
<p>[3] J. Koomey, <em>Growth in data center electricity use 2005 to 2010</em>. Oakland, CA: Analytics Press, 2011.</p>
<p>[4] Gartner Inc., <em>Gartner estimates ICT industry accounts for 2 percent of global CO2 emissions</em>. Gartner Press Release (April 2007).</p>
<p>[5] R. Nathuji and K. Schwan, “VirtualPower: Coordinated power management in virtualized enterprise systems,” <em>ACM SIGOPS Operating Systems Review</em>, vol. 41, pp. 265–278, 2007.</p>
<p>[6] A. Verma, P. Ahuja, and A. Neogi, “pMapper: Power and migration cost aware application placement in virtualized systems,” in <em>Proc. of the 9th ACM/IFIP/USENIX Intl. Conf. on Middleware</em>, 2008, pp. 243–264.</p>
<p>[7] X. Zhu, D. Young, B. J. Watson, Z. Wang, J. Rolia, S. Singhal, B. McKee, C. Hyser, and others, “1000 Islands: Integrated capacity and workload management for the next generation data center,” in <em>Proc. of the 5th Intl. Conf. on Autonomic Computing (ICAC)</em>, 2008, pp. 172–181.</p>
<p>[8] D. Gmach, J. Rolia, L. Cherkasova, G. Belrose, T. Turicchi, and A. Kemper, “An integrated approach to resource pool management: Policies, efficiency and quality metrics,” in <em>Proc. of the 38th IEEE Intl. Conf. on Dependable Systems and Networks (DSN)</em>, 2008, pp. 326–335.</p>
<p>[9] D. Gmach, J. Rolia, L. Cherkasova, and A. Kemper, “Resource pool management: Reactive versus proactive or lets be friends,” <em>Computer Networks</em>, vol. 53, pp. 2905–2922, 2009.</p>
<p>[10] VMware Inc., “VMware Distributed Power Management Concepts and Use,” <em>Information Guide</em>, 2010.</p>
<p>[11] G. Jung, M. A. Hiltunen, K. R. Joshi, R. D. Schlichting, and C. Pu, “Mistral: Dynamically Managing Power, Performance, and Adaptation Cost in Cloud Infrastructures,” in <em>Proc. of the 30th Intl. Conf. on Distributed Computing Systems (ICDCS)</em>, 2010, pp. 62–73.</p>
<p>[12] W. Zheng, R. Bianchini, G. J. Janakiraman, J. R. Santos, and Y. Turner, “JustRunIt: Experiment-based management of virtualized data centers,” in <em>Proc. of the 2009 USENIX Annual Technical Conf.</em>, 2009, pp. 18–33.</p>
<p>[13] S. Kumar, V. Talwar, V. Kumar, P. Ranganathan, and K. Schwan, “vManage: Loosely coupled platform and virtualization management in data centers,” in <em>Proc. of the 6th Intl. Conf. on Autonomic Computing (ICAC)</em>, 2009, pp. 127–136.</p>
<p>[14] B. Guenter, N. Jain, and C. Williams, “Managing Cost, Performance, and Reliability Tradeoffs for Energy-Aware Server Provisioning,” in <em>Proc. of the 30st Annual IEEE Intl. Conf. on Computer Communications (INFOCOM)</em>, 2011, pp. 1332–1340.</p>
<p>[15] N. Bobroff, A. Kochut, and K. Beaty, “Dynamic placement of virtual machines for managing SLA violations,” in <em>Proc. of the 10th IFIP/IEEE Intl. Symp. on Integrated Network Management (IM)</em>, 2007, pp. 119–128.</p>
<p>[16] A. Beloglazov, R. Buyya, Y. C. Lee, and A. Zomaya, “A Taxonomy and Survey of Energy-Efficient Data Centers and Cloud Computing Systems,” <em>Advances in Computers, M. Zelkowitz (ed.)</em>, vol. 82, pp. 47–111, 2011.</p>
<p>[17] A. Beloglazov, S. F. Piraghaj, M. Alrokayan, and R. Buyya, “A Step-by-Step Guide to Installing OpenStack on CentOS Using the KVM Hypervisor and GlusterFS Distributed File System,” <em>Technical Report CLOUDS-TR-2012-3, Cloud Computing and Distributed Systems Laboratory, The University of Melbourne</em>, Jul. 2012.</p>
